local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Kryo Hub â”ƒ Bubble Gum Simulator Infinity",
   Icon = "kanban-square", -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Bubble Gum Simulator Infinity",
   LoadingSubtitle = "by kryo",
   Theme = "DarkBlue", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = "BGSI", -- Create a custom folder for your hub/game
      FileName = "Kryo Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "https://discord.gg/vqEcd8tJgx", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = false -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "https://discord.gg/2uhDaymwgQ", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local BubbleTab = Window:CreateTab("Bubble", "chevron-down-circle") 
local TeleportTab = Window:CreateTab("Teleport", "navigation")
local EggTab = Window:CreateTab("Egg", "egg")
local RiftTab = Window:CreateTab("Rifts", "database")
local MiscTab = Window:CreateTab("Misc", "monitor")
local BubbleSection = BubbleTab:CreateSection("Blow Bubble")
local TeleportSection = TeleportTab:CreateSection("Teleport To Worlds")
local EggSection = EggTab:CreateSection("Auto Open Eggs")
local MiscSection = MiscTab:CreateSection("Miscellaneous")


-- local variables
local isBlowing, isSelling, isOpening, isHidingAnim, isAutowheel, isautoclaimplaytime, isautomystery = false, false, false, false, false, false, false
local sellloc, bubbletoSell, eggamounttoopen, mysteryopen = nil, nil, nil, nil
local selectedEgg, openAmount = nil, 1
local lastPlayerPosition = Vector3.new(0, 0, 0)

-- game variables
local RunService = game:GetService("RunService")
local VirtualUser = game:GetService("VirtualUser")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
local replicatedstorage = game:GetService("ReplicatedStorage")
local remoteEvent = replicatedstorage:WaitForChild("Shared", 9e9)
    :WaitForChild("Framework", 9e9)
    :WaitForChild("Network", 9e9)
    :WaitForChild("Remote", 9e9)
    :WaitForChild("RemoteEvent", 9e9)
local remoteFunction = replicatedstorage:WaitForChild("Shared", 9e9)
	:WaitForChild("Framework", 9e9)
	:WaitForChild("Network", 9e9)
	:WaitForChild("Remote", 9e9)
	:WaitForChild("RemoteFunction", 9e9)
local rendered = game.workspace.Rendered
--- Modules
local localDataModule = require(replicatedstorage.Client.Framework.Services.LocalData)
local Time = require(replicatedstorage.Shared.Framework.Utilities.Math.Time)
local localData = localDataModule.Get and localDataModule:Get() or localDataModule
local statsUtil = require(replicatedstorage.Shared.Utils.Stats.StatsUtil)
local itemUtil = require(replicatedstorage.Shared.Utils.Stats.ItemUtil)
local playtimeData = require(replicatedstorage.Shared.Data.Playtime)
local maxStorage = statsUtil:GetBubbleStorage(localData)
local Prizes = require(replicatedstorage.Shared.Data.Prizes)

-- game tables
local u45 = {
    ["Type"] = "Powerup",
    ["Name"] = "Spin Ticket",
    ["Amount"] = 1
}

local ActiveGifts = {}
local portalPaths = {
    ["The Overworld"] = "Workspace.Worlds.The Overworld.PortalSpawn",
    ["Floating Island"] = "Workspace.Worlds.The Overworld.Islands.Floating Island.Island.Portal.Spawn",
    ["Outer Space"] = "Workspace.Worlds.The Overworld.Islands.Outer Space.Island.Portal.Spawn",
    ["Twilight"] = "Workspace.Worlds.The Overworld.Islands.Twilight.Island.Portal.Spawn",
    ["The Void"] = "Workspace.Worlds.The Overworld.Islands.The Void.Island.Portal.Spawn",
    ["Zen"] = "Workspace.Worlds.The Overworld.Islands.Zen.Island.Portal.Spawn"
}

local order = {"The Overworld","Floating Island", "Outer Space", "Twilight", "The Void", "Zen"}
local eggNames = {}
local codes = {
	"release",
	"lucky",
	"easter",
	"update2",
	"update3",
	"sylentlysorry"
}
local eggLocations = {
   ["Common Egg"] = CFrame.new(-12.5052786, 15.2256365, -81.8115845, 0.972688317, 0, -0.23211512, 0, 1, 0, 0.23211512, 0, 0.972688317),
   ["Spotted Egg"] = CFrame.new(-12.5052786, 15.4313774, -70.8115845, 0.939065695, 0, -0.343737692, 0, 1, 0, 0.343737692, 0, 0.939065695),
   ["Iceshard Egg"] = CFrame.new(-12.5052786, 15.6988993, -59.8115845, -0.988525927, 0, -0.151051342, 0, 1, 0, 0.151051342, 0, -0.988525927),
   ["200M Egg"] =  CFrame.new(16.7684441, 15.884573, -6.39064121, -0.261815399, 0, 0.965117991, 0, 1, 0, -0.965117991, 0, -0.261815399),
   ["Spikey Egg"] = CFrame.new(-6.57140636, 429.365112, 162.804047, 0.635180771, 0, 0.772363484, 0, 1, 0, -0.772363484, 0, 0.635180771),
   ["Crystal Egg"] = CFrame.new(-23.2449455, 2671.25024, 18.7663269, -0.86546433, 0, 0.500970542, 0, 1, 0, -0.500970542, 0, -0.86546433),
   ["Magma Egg"] = CFrame.new(-23.2449455, 2671.43652, 8.2663269, 0.886782229, 0, -0.462187499, 0, 1, 0, 0.462187499, 0, 0.886782229),
   ["Lunar Egg"] = CFrame.new(-57.4440575, 6868.73828, 74.9474182, -0.875178516, 0, -0.483800113, 0, 1, 0, 0.483800113, 0, -0.875178516),
   ["Void Egg"] = CFrame.new(8.92448807, 10153.9141, 190.473053, 0.401110411, 0, -0.916029692, 0, 1, 0, 0.916029692, 0, 0.401110411),
   ["Hell Egg"] = CFrame.new(-7.30945969, 10155.21, 197.550446, -0.820726931, 0, 0.571320653, 0, 1, 0, -0.571320653, 0, -0.820726931),
   ["Nightmare Egg"] = CFrame.new(-21.7841911, 10155.9414, 187.750641, -0.459208816, 0, 0.888328373, 0, 1, 0, -0.888328373, 0, -0.459208816),
   ["Rainbow Egg"] = CFrame.new(-37.4001427, 15978.666, 49.4806213, -0.978604555, 0, 0.205750033, 0, 1, 0, -0.205750033, 0, -0.978604555),
}

-- Map each egg to its corresponding world
local eggToWorld = {
   ["Common Egg"] = "The Overworld",
   ["Spotted Egg"] = "The Overworld",
   ["Iceshard Egg"] = "The Overworld",
   ["200M Egg"] = "The Overworld",
   ["Spikey Egg"] = "Floating Island",
   ["Crystal Egg"] = "Outer Space",
   ["Magma Egg"] = "Outer Space",
   ["Lunar Egg"] = "Twilight",
   ["Void Egg"] = "The Void",
   ["Hell Egg"] = "The Void",
   ["Nightmare Egg"] = "The Void",
   ["Rainbow Egg"] = "Zen",
}

-- ui tables
local eggnumberoptions = {"1", "Max"}
-- Functions
local function fireRemote(action, ...)
   remoteEvent:FireServer(action, ...)
end
local function teleport(path)
   fireRemote("Teleport", path)
end

local function openEgg(egg, amount)
   fireRemote("HatchEgg", egg, amount)
end


local function openGift(giftamount)
    fireRemote("UseGift", "Mystery Box", giftamount)
end

local function claimGift(giftId)
    fireRemote("ClaimGift", giftId)
end
local function claimQuest(prizeId)
    fireRemote("ClaimPrize", prizeId)
end
local function fireRemoteFunction(action, ...)
   remoteFunction:InvokeServer(action, ...)
end

local function autoClaimPlaytime(rewardindex)
    fireRemoteFunction("Claimplaytime", rewardindex)
end

local function redeemcode(code)
	fireRemoteFunction("RedeemCode", code)
end


local function CheckForNewGifts()
    if not workspace:FindFirstChild("Rendered") then
        return  -- Gifts folder doesn't exist yet
    end
    
    local giftsFolder = workspace.Rendered:FindFirstChild("Gifts")
    if not giftsFolder then
        return  -- Gifts folder doesn't exist yet
    end
    
    -- Check all gifts in the folder
    for _, gift in pairs(giftsFolder:GetChildren()) do
        if not ActiveGifts[gift.Name] then
            -- New gift found, add to our tracking list
            ActiveGifts[gift.Name] = {
                model = gift,
                hitCount = 0,
                timeAdded = tick()
            }
            print("New gift detected: " .. gift.Name)
        end
    end
end

local function ProcessGifts()
    -- Check if any gifts are ready to be collected (hit 8 times)
    for giftId, giftData in pairs(ActiveGifts) do
        -- If the gift has been around for a while, try to claim it
        if tick() - giftData.timeAdded > 3 then
            claimGift(giftId)
        end
    end
end

local function updateMaxOpenOptions()
    if localData and localData.Stats then
        local maxHatch = statsUtil:GetMaxEggHatches(localData)
        local options = {1}
        for i = 2, maxHatch do
            table.insert(options, i)
        end
        table.insert(options, "Max")
        if eggamounttoopen then
            pcall(function()
                eggamounttoopen:Update(openAmount, options)
            end)
        end
    end
end
local function getEggNames()
    local eggs = replicatedstorage.Assets.Eggs
    local eggNames = {}
    if eggs then
        for _, egg in pairs(eggs:GetChildren()) do
            if egg:IsA("Model") and not string.find(egg.Name, "Golden") then
                table.insert(eggNames, egg.Name)
            end
        end
    else
        warn("Eggs not found")
    end
    return eggNames
end
eggNames = getEggNames()



local AutoBlowBubble = BubbleTab:CreateToggle({
   Name = "Auto Blow Bubble",
   CurrentValue = false,
   Flag = "BlowingBubble", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(state)
      isBlowing = state
      while isBlowing do
         fireRemote("BlowBubble")
         task.wait(0.3)
      end
   end,
})

local SellSection = BubbleTab:CreateSection("Sell Bubble")

local SelectPercentTosell = BubbleTab:CreateSlider({
   Name = "Select Percent To sell",
   Range = {1,100},
   Increment = 1,
   Suffix = "%",
   CurrentValue = 20,
   Flag = "PercentSell",
   Callback = function(value)
      bubbletoSell = value
   end
})
SelectPercentTosell:Set(20)
local SellLocation = BubbleTab:CreateDropdown({
   Name = "Sell Location",
   Options = {"The Overworld", "Twilight"},
   CurrentOption = {"The Overworld"},
   MultipleOptions = false,
   Flag = "SellLocation",
   Callback = function(Options)
      local selectedOption = Options[1] -- Extract the first value from the table
      sellloc = portalPaths[selectedOption] -- Use the string value as a key to access portalPaths
   end
})
SellLocation.Callback({"The Overworld"})
local AutoSell = BubbleTab:CreateToggle({
   Name = "Auto Sell Bubble",
   CurrentValue = false,
   Flag = "SellingBubble", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(state)
      isSelling = state

      while isSelling do
         if sellloc then
            if localData and localData.Bubble and maxStorage then
               local sellThreshold = (bubbletoSell / 100) * maxStorage
               if localData.Bubble.Amount >= sellThreshold then
                  teleport(sellloc)
                  task.wait(0.5)
                  fireRemote("SellBubble")
               end
            end
         end
         task.wait(1)
      end
   end
})
for _, location in pairs(order) do
local TeleportButton = TeleportTab:CreateButton({
   Name = location, 
   Callback = function()
      teleport(portalPaths[location])
   end
})
end

-- Enhanced egg handling code with improved teleportation
local isAtEggLocation = false -- Flag to track if player is at egg location
local lastTeleportTime = 0 -- Track when we last teleported
local teleportCooldown = 3 -- Cooldown in seconds between teleports to prevent spam
local currentWorld = "Unknown" -- Track which world the player is currently in

-- Function to check if a player has moved a significant distance
local function hasPlayerTeleported()
    if not humanoidRootPart then return false end
    
    local currentPosition = humanoidRootPart.Position
    local distance = (currentPosition - lastPlayerPosition).Magnitude
    
    -- If distance is large, player likely teleported
    if distance > 50 then
        lastPlayerPosition = currentPosition
        return true
    end
    
    lastPlayerPosition = currentPosition
    return false
end

-- Function to teleport to the correct world for a given egg
local function teleportToEggWorld(eggName)
    local targetWorld = eggToWorld[eggName]
    if not targetWorld then
        warn("No world mapping for egg:", eggName)
        return false
    end
    
    -- If we're already in the correct world, no need to teleport
    if currentWorld == targetWorld then
        print("Already in the correct world: " .. targetWorld)
        return true
    end
    
    print("Teleporting to world: " .. targetWorld)
    teleport(portalPaths[targetWorld])
    lastTeleportTime = tick()
    currentWorld = targetWorld
    task.wait(2) -- Wait for teleport to complete
    
    return true
end

local function moveToEggLocation(eggName, forceMode)
    if not eggLocations[eggName] then
        warn("No location data for egg:", eggName)
        return false
    end
    
    -- First ensure we're in the correct world
    if not teleportToEggWorld(eggName) then
        warn("Failed to teleport to correct world for egg:", eggName)
        return false
    end
    
    -- Update last position for teleport detection
    lastPlayerPosition = humanoidRootPart.Position
    
    -- Calculate distance from egg
    local distance = (humanoidRootPart.Position - eggLocations[eggName].Position).Magnitude
    
    -- If already close enough and not forcing a specific mode
    if distance <= 20 and not forceMode then
        print("Already close to egg, no movement needed")
        isAtEggLocation = true
        return true
    end
    
    -- Tween to the egg location
    print("Tweening to egg location (distance: " .. distance .. ")")
    local tweenInfo = TweenInfo.new(math.min(3, math.max(1, distance/30)), Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tweenGoal = {CFrame = eggLocations[eggName]}
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, tweenGoal)
    tween:Play()
    
    local success = pcall(function()
        tween.Completed:Wait()
    end)
    
    if success then
        isAtEggLocation = true
        return true
    else
        warn("Tween to egg location failed")
        return false
    end
end

local function startEggOpening()
    if not selectedEgg then
        warn("No egg selected")
        return
    end
    
    -- Set initial player position for teleport detection
    if humanoidRootPart then
        lastPlayerPosition = humanoidRootPart.Position
    end
    
    -- Position check loop
    spawn(function()
        while isOpening do
            -- Check if player has teleported away
            if humanoidRootPart and isAtEggLocation then
                local hasTeleported = hasPlayerTeleported()
                local currentPosition = humanoidRootPart.Position
                local targetPosition = eggLocations[selectedEgg].Position
                local distance = (currentPosition - targetPosition).Magnitude
                
                if hasTeleported or distance > 100 then
                    -- Player has likely teleported away or is too far
                    print("Player detected far from egg location (distance: " .. distance .. "), repositioning")
                    isAtEggLocation = false
                    moveToEggLocation(selectedEgg, "teleport") -- Force teleport mode
                elseif distance > 20 then
                    -- Player is moderately far, just tween
                    print("Moderate distance from egg, repositioning with tween")
                    isAtEggLocation = false
                    moveToEggLocation(selectedEgg, "tween") -- Force tween mode
                end
            end
            task.wait(1)
        end
    end)
    
    -- Egg opening loop
    spawn(function()
        if moveToEggLocation(selectedEgg) then
            while isOpening do
                if isAtEggLocation then
                    -- Fire the remote event to open egg
                    openEgg(selectedEgg, openAmount)
                    task.wait(0.5) -- Short wait between opening attempts
                else
                    task.wait(0.1) -- Wait for position to be established
                end
            end
        end
    end)
end

local Autoopen = EggTab:CreateToggle({
    Name = "Auto open selected egg",
    CurrentValue = false,
    Flag = "isopeningegg",
    Callback = function(Value)
        isOpening = Value
        isAtEggLocation = false -- Reset position flag
        if not isOpening then
            return
        end
        if isOpening then
            startEggOpening()
        end
    end
})

local HideAnimation = EggTab:CreateToggle({
   Name = "Hide Egg Animation", 
   CurrentValue = false,
   Flag = "hidingegganimation",
   Callback = function(Value)
      isHidingAnim = Value
      local eggHatchModule 
      local originalPlay
      local originalDisplayPetOnce
      for _, v in pairs(getgc(true)) do
        if type(v) == "table" and rawget(v, "Play") and rawget(v, "DisplayPetOnce") then
            eggHatchModule = v
            break
        end
    end
    if isHidingAnim then
        if eggHatchModule then
            -- Save the original functions if not already saved
            if not originalPlay then
                originalPlay = eggHatchModule.Play
            end
            if not originalDisplayPetOnce then
                originalDisplayPetOnce = eggHatchModule.DisplayPetOnce
            end

            -- Overwrite the Play function to prevent animations
            eggHatchModule.Play = function() end
            eggHatchModule.DisplayPetOnce = function() end
        end
    else
        -- Restore original functions when toggled off
        if eggHatchModule and originalPlay and originalDisplayPetOnce then
            eggHatchModule.Play = originalPlay
            eggHatchModule.DisplayPetOnce = originalDisplayPetOnce
        end
    end
   end
})

local SelectHowManyToOpen = EggTab:CreateDropdown({
   Name = "# Of egg to open",
   Options = eggnumberoptions,
   CurrentOption = eggnumberoptions[1],
   MultipleOptions = false,
   Flag = "NumberToOpen",
   Callback = function(selected)
       if selected[1] == "Max" then
           openAmount = statsUtil:GetMaxEggHatches(localData) or 1
       else
           openAmount = tonumber(selected[1]) or 1
       end
       print("Set open amount to:", openAmount) -- Debug
   end
})

updateMaxOpenOptions()

local SelectEgg = EggTab:CreateDropdown({
   Name = "Select Egg To Open",
   Options = eggNames,
   CurrentOption = eggNames[1],
   MultipleOptions = false,
   Flag = "SelectedEgg",
   Callback = function(selected)
      selectedEgg = selected[1]
      print("Selected egg:", selectedEgg) -- Debug
      
      -- If already opening eggs, reset position for new egg
      if isOpening then
          isAtEggLocation = false
          startEggOpening()
      end
   end
})
SelectEgg.Callback({eggNames[1]})
-- Track world changes with a connection
local worldChangeDetector = workspace.ChildAdded:Connect(function(child)
    if isOpening and child.Name == "Worlds" then
        print("World change detected")
        task.wait(1) -- Give time for world to load
        isAtEggLocation = false -- Reset position when world changes
        
        -- Try to detect which world we're in now
        local worldsFolder = workspace:FindFirstChild("Worlds")
        if worldsFolder then
            for _, worldName in ipairs(order) do
                if worldsFolder:FindFirstChild(worldName) then
                    currentWorld = worldName
                    print("Detected new world: " .. currentWorld)
                    break
                end
            end
        end
    end
end)

-- Character respawn handling
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    
    -- If we were opening eggs, reset position flag
    if isOpening then
        isAtEggLocation = false
        task.wait(1) -- Give a moment for character to load
        startEggOpening() -- Resume egg opening
    end
end)

-- Clean up connections when script ends
game:GetService("Players").PlayerRemoving:Connect(function(plr)
    if plr == player then
        if worldChangeDetector then
            worldChangeDetector:Disconnect()
        end
    end
end)


----

local SpinTheWheel = MiscTab:CreateToggle({
    Name = "Auto Wheel Spin",
    CurrentValue = false,
    Flag = "WheelSpin",
    Callback = function(state)
        isAutowheel = state
        while isAutowheel do
            if localData and localData.NextWheelSpin then
                if not localData and localData.NextWheelSpin then
                    break
                end
                -- claim free spin logic
                local nextspin = localData.NextWheelSpin - Time.now()
                if nextspin <= 0 then
                    local success, error = pcall(function ()
                        fireRemote("ClaimFreeWheelSpin")
                    end)
                    if not success then
                        print("lolers")
                    end
                    task.wait(1)
                end
                --ticket logic
                local ticketamount = itemUtil:GetOwnedAmount(localData, u45)
                if ticketamount and ticketamount > 0 then
                    local freespinsucess, freespinerror = pcall(function()
                        fireRemoteFunction("WheelSpin")
                    end)
                    if freespinsucess then
                        fireRemote("ClaimWheelSpinQueue")
                        task.wait(1.5)
                    end
                end
            end
            task.wait(2)
        end
    end
})

local AutoClaimPlaytime = MiscTab:CreateToggle({
    Name = "Auto Claim Playtime",
    CurrentValue = false,
    Flag = "autoclaimingPlaytime",
    Callback = function(state)
        isautoclaimplaytime = state

        local function monitorPlaytimeRewards()
            
            while isautoclaimplaytime do
            local laytimeData = require(replicatedstorage.Shared.Data.Playtime)
            if localData and laytimeData and Time.now() then
                local elapsetime = Time.now() - localData.PlaytimeRewards.Start
                for rewardsIndex, rewardsData in pairs(laytimeData.Gifts) do
                    local timeremaining = math.max(0, rewardsData.Time - elapsetime)
                    local isclaimed = localData.PlaytimeRewards.Claimed[tostring(rewardsIndex)] ~= nil

                    if timeremaining == 0 and not isclaimed then
                       local success = require(replicatedstorage.Shared.Framework.Network.Remote):InvokeServer("ClaimPlaytime", rewardsIndex)
                    end
                end
            end
            task.wait(2)
        end
        end

        if isautoclaimplaytime then
            spawn(monitorPlaytimeRewards)
        end
    end
})


local redeemallcode = MiscTab:CreateButton({
    Name = "Redeem All Available Codes",
    Callback = function ()
        for i, v in ipairs(codes) do
            redeemcode(v)
        end
    end
})

local numberofgiftopen = MiscTab:CreateDropdown({
    Name = "Select # Of Mystery Box to open",
    Options = {"1", "5", "10"},
    CurrentOption = "1", -- Initial display
    MultipleOptions = false,
    Flag = "mysterynumberopen",
    Callback = function(selected)
        mysteryopen = selected[1]
    end
})
numberofgiftopen.Callback({"1"})

local openingdelay = 1
local lastusetime = 0

local isautomystery = MiscTab:CreateToggle({
    Name = "Auto Mystery Box",
    CurrentValue = false,
    Flag = "isautomystery",
    Callback = function(Value)
        isautomystery = Value
        
        -- Create a separate spawn thread for the mystery box loop
        if isautomystery then
            spawn(function()
                while isautomystery do
                    local timenow = tick()
                    
                    CheckForNewGifts()
                    ProcessGifts()
                    
                    -- Use mystery boxes at the specified interval
                    if timenow - lastusetime >= openingdelay then
                        if mysteryopen and tonumber(mysteryopen) then
                            openGift(tonumber(mysteryopen))
                        else
                            openGift(1) -- Default to 1 if value is invalid
                        end
                        lastusetime = timenow
                    end
                    
                    task.wait(2)
                end
            end)
        end
    end
})
local QuestSelected = nil
local isclaimingquest = false

local questselecte = MiscTab:CreateDropdown({
    Name = "Select Quest To Auto Collect",
    Options = {"Bubbles", "Eggs"},
    CurrentOption = "Bubbles",
    MultipleOptions = true, 
    Flag = "selectedquest",
    Callback = function(selected)
        QuestSelected = selected  
        local lookup = {}
        for _, value in ipairs(selected) do
            lookup[value] = true
        end
    end
})


local function autoClaimQuest()
    -- Make sure QuestSelected is always a table
    if type(QuestSelected) == "string" then
        QuestSelected = { QuestSelected }
    end

    for prizeId, prizeInfo in pairs(Prizes) do
        local requirement = prizeInfo.Requirement

        for _, selectedType in ipairs(QuestSelected) do
            if prizeInfo.Type == selectedType then
                local current = localData.Stats[selectedType]
                local claimed = localData.ClaimedPrizes[prizeInfo.Key] ~= nil

                if current ~= nim and not claimed and current >= requirement then
                    claimQuest(prizeId)
                end
            end
        end
    end
end
local AutoClaimQuest = MiscTab:CreateToggle({
    Name = "Auto Claim Selected Quest",
    CurrentValue = false,
    Flag = "autoclaimingselectedquest",
    Callback = function(value)
        isclaimingquest = value
        while isclaimingquest do
            autoClaimQuest()
            task.wait(1)
        end
    end
})
















--------- anti afk
local Players = game:GetService("Players")
local VirtualUser = game:GetService("VirtualUser")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local AFK_TIMEOUT = 720 -- Time in seconds before AFK actions are triggered.

-- Variable to track the last input time
local lastInputTime = tick()

-- Function to simulate activity to prevent AFK kick
local function preventAFK()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.new(0, 0)) -- Simulate right-click
end

-- Update the last input time whenever the player provides input
UserInputService.InputBegan:Connect(function()
    lastInputTime = tick() -- Update the last input time to the current tick
end)

-- Connect to Player.Idled event
LocalPlayer.Idled:Connect(function()
    preventAFK() -- Trigger the preventAFK function when the player is idle
end)

-- Additional logic to handle AFK-specific scenarios
local function handleIdleTimer(elapsedTime)
    if elapsedTime >= AFK_TIMEOUT then
        preventAFK() -- Take action if the player is AFK for too long
    end
end

-- Simulate periodic checks for AFK
while true do
    task.wait(30) -- Check every 30 seconds
    local idleTime = tick() - lastInputTime -- Calculate idle time based on the last input
    handleIdleTimer(idleTime) -- Handle the AFK timeout logic
end

Rayfield:LoadConfiguration()
